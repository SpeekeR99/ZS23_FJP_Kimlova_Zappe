program::=
    decl_var_stmt program
    | decl_func_stmt program
    | /* empty */

decl_var_stmt::=
    TYPE ID SEMICOLON
    | CONSTANT TYPE ID SEMICOLON
    | TYPE assign_stmt
    | CONSTANT TYPE assign_stmt

assign_stmt::=
    ID ASSIGN_OP expr SEMICOLON

decl_func_stmt::=
    TYPE ID L_BRACKET params R_BRACKET block
    TYPE ID L_BRACKET params R_BRACKET SEMICOLON

params::=
    TYPE ID COMMA params
    | /* empty */

block::=
    BEGIN_BLOCK stmts END_BLOCK

stmts::=
    stmt stmts
    | /* empty */

stmt::=
    decl_var_stmt
    | assign_stmt
    | if_stmt
    | while_stmt
    | for_stmt
    | call_func_stmt
    | return_stmt

if_stmt::=
    IF L_BRACKET expr R_BRACKET block else_stmt

else_stmt::=
    ELSE block
    | /* empty */

while_stmt::=
    WHILE L_BRACKET expr R_BRACKET block

for_stmt::=
    FOR L_BRACKET expr SEMICOLON expr SEMICOLON expr R_BRACKET block

call_func_stmt::=
    call_func_expr SEMICOLON

args::=
    expr COMMA args
    | /* empty */

return_stmt::=
    RETURN expr SEMICOLON

expr::=
    ID
    | LITERAL
    | L_BRACKET expr R_BRACKET
    | arithm_expr
    | logic_expr
    | cast_expr
    | call_func_expr

arithm_expr::=
    expr SUM expr
    | expr SUB expr
    | expr MUL expr
    | expr DIV expr
    | expr MOD expr
    | U_MINUS expr /* unary minus */

logic_expr::=
    expr AND expr
    | expr OR expr
    | NOT expr

cast_expr::=
    L_BRACKET TYPE R_BRACKET expr

call_func_expr::=
    ID L_BRACKET args R_BRACKET

SEMICOLON::= ';'
CONSTANT::= 'const'
ASSIGN_OP::= '='
L_BRACKET::= '('
R_BRACKET::= ')'
COMMA::= ','
BEGIN_BLOCK::= '{'
END_BLOCK::= '}'
IF::= 'if'
ELSE::= 'else'
WHILE::= 'while'
FOR::= 'for'
RETURN::= 'return'
SUM::= '+'
SUB::= '-'
MUL::= '*'
DIV::= '/'
MOD::= '%'
U_MINUS::= '-'
AND::= '&&'
OR::= '||'
NOT::= '!'
